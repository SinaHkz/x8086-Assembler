<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.0.2/dist/css/bootstrap.min.css" rel="stylesheet" integrity="sha384-EVSTQN3/azprG1Anm3QDgpJLIm9Nao0Yz1ztcQTwFspd3yD65VohhpuuCOmLASjC" crossorigin="anonymous">
    <link href="https://fonts.googleapis.com/css2?family=PT+Serif&display=swap" rel="stylesheet">
    <link href="https://fonts.googleapis.com/css2?family=Montserrat&display=swap" rel="stylesheet">
    <link rel="stylesheet" href="{{ url_for('static', filename='style.css') }}">
    <!--{{ url_for('static', filename='style.css') }}-->
    <title>Flask Frontend</title>
</head>
<body>
    <div class="section1">
        <h1 class="header">x86 Assembler for assembly course in Shiraz University</h1>
        <h3 class="header-h3">This Assembler assemble these instruction types:</h3>
        <pre>INSTRUCTION REG,REG   |   INSTRUCTION REG/MEM   |   INSTRUCTION MEM/REG   |   INSTRUCTION REG   |   INSTRUCTION IMM|   INSTRUCTION REG,IMM</pre>
        <div class="inputDiv">
            <label for="input">Enter your Assembly code:</label>
            <textarea class="inputArea" type="text" id="input" cols="30" rows="10" placeholder="write your instructions"></textarea>
            <button class="btn btn-ghost" onclick="runScript()"> <span class="button-text"> Assemble </span></button>
        </div>
        <div class="outputDiv">
            <textarea class="readOnly" id="output" cols="30" rows="10"></textarea>
        </div>
    </div>
    <div class=" first-container">
        <div class= "container">
            <h1>Introduction to what we do</h1>
            <p> let's take a look at what happens when an assembler assembles a code. We use 32-bit assembly and support only
                certain modes, so we're working to understand those modes better. Usually in supported format we have two
                general byte to specify an instruction and its operand(s). 1) opCode 2) Mod-REG-R/M</p>
            <div class="opcode">
                <h3>opCode</h3>
                <p>1. Six MSB bits that specify the Instruction.</p>
                <img src="{{ url_for('static', filename='Screenshot 2023-12-18 at 7.21.07 PM.png') }}">
                <p>2. The second bit, called ‘d’, shows whether the part in the second byte is for the destination or source. If
                    d = 0, REG is the source and R/M is the destination, otherwise, it’s the other way around.</p>
                <p>3. The LSB bit, called ‘s’, shows whether the register in the operands is 8-bit or 16/32-bit. If s = 0, it
                    means REG is an 8-bit register, otherwise, it’s a 16/32-bit register. Question: how to understand whether a
                    register is 16-bit or 32-bit ? Answer: we add a prefix for 16-bit register to specify it from 32-bit.</p>
            </div>
            <div class="mod">
                <h3>Mod-REG-R/M</h3>
                <p>This byte also has three part: </p>
                <ol>
                    <li>The two most significant bits (MSBs) represent the mod part, specifying the type of process we are
                        performing. We use only 11 and 00 mods in this project.
                    </li>
                    <img src="{{ url_for('static', filename='Screenshot 2023-12-18 at 7.14.16 PM.png') }}" alt="">
                    <li>Next three bits represent the REG part, show register code</li>
                    <li>The three least significant bits (LSBs) represent either the memory or the second register used in the
                        code.
                    </li>
                    <img src="{{ url_for('static', filename='Screenshot 2023-12-18 at 7.14.00 PM.png') }}" alt="">
                </ol>
            </div>
        </div>
    </div>

    <div class="container second-container">
        <div class="row">
            <div class="one-operand col-md-6 one-operand">
                <h3>One operand instructions</h3>
                <p>These instructions have their own opCode type and we discuss them separately.</p>
                <h4>inc:</h4>
                <ol>
                    <li>The opcode for 32-bit registers is represented as 40h + [REG value]. This value is in hexadecimal
                        format, and the addition should be performed using hexadecimal numbers.
                    </li>
                    <li>The opCode for 16-bit register is represented as 32-bit does but with an addition of 66 prefix.</li>
                    <li>The opCode of the 8-bit register is represented as “FE xx000xxx”. xx is mod and xxx is register
                        value.
                    </li>
                </ol>
                <h4>dec</h4>
                <ol>
                    <li>The opcode for 32-bit registers is represented as 48h + [REG value]. This value is in hexadecimal 
                        format, and the addition should be performed using hexadecimal numbers.
                    </li>
                    <li>The opCode for 16-bit register is represented as 32-bit does but with an addition of 66 prefix.</li>
                    <li>The opCode of the 8-bit register is represented as “FE xx001xxx”. xx is mod and xxx is register
                        value.
                    </li>
                </ol>
                <h4>push</h4>
                <ol>
                    <li>The opcode for 32-bit registers is represented as 50h + [REG value]. This value is in hexadecimal
                        format, and the addition should be performed using hexadecimal numbers.
                    </li>
                    <li>The opCode for 16-bit register is represented as 32-bit does but with an addition of 66 prefix.</li>
                </ol>
                <p><i>Note: push instruction machine code when push an immediate value is “6a immValue”. If immValue is
                    between -128 and 127 it will be written in 1 byte otherwise written in 4 byte and ofcourse in little
                    endian.</i></p>
                <h4>pop</h4>
                <li>The opcode for 32-bit registers is represented as 58h + [REG value]. This value is in hexadecimal
                    format, and the addition should be performed using hexadecimal numbers.
                </li>
                <li>The opCode for 16-bit register is represented as 32-bit does but with an addition of 66 prefix.</li>
            </div>
            <div class="col-md-6">
                <div class="jmp">
                    <h3>Jmp instruction</h3>
                    <p>Jmp instruction opCode is “eb” and the second byte of its machine code is the space of label between jmp
                        and label.</p>
                </div>
                <div class="imm">
                    <h3>immediate value</h3>
                    <p>When use immediate value in two instruction operands use these structures:</p>
                    <img src="">
                    <p>For other instructions add the instruction specific number to 04/05 and for the other formula replace
                        “000” with the Xs in instruction opCode( --XXX- ). Then convert the immediate value into hexadecimal
                        form and use it as the second part of machine code. </p>
                    <p><i>Note: if immediate value would be between -128 to 127 we convert it into 1 byte otherwise into 4
                        bytes.</i></p>
                </div>
            </div>
        </div>
    </div>
    <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.0.2/dist/js/bootstrap.bundle.min.js" integrity="sha384-MrcW6ZMFYlzcLA8Nl+NtUVF0sA7MsXsP1UyJoMp4YLEuNSfAP+JcXn/tWtIaxVXM" crossorigin="anonymous"></script>
    <script>
        function runScript() {
            var input = document.getElementById('input').value;

            fetch('/assembler', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                },
                body: JSON.stringify({input: input}),
            })
                // text/plain
                .then(response => response.json())
                .then(data => {
                    document.getElementById('output').innerText = data.output;
                });
        }
    </script>
    </body>
</html>